// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_DATABASE_URL")
}

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  name         String
  firstName    String?
  lastName     String?
  username     String?  @unique // Personal booking link username
  password     String? // For email/password auth
  plan         String   @default("free")
  bookingCount Int      @default(0)
  resetDate    DateTime @default(now())

  // Stripe subscription fields
  stripeCustomerId         String?   @unique
  stripeSubscriptionId     String?   @unique
  stripeSubscriptionStatus String? // active, canceled, past_due, trialing, incomplete
  subscriptionEndsAt       DateTime? // When current period ends
  cancelAtPeriodEnd        Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Profile meeting defaults
  defaultVideoLink    String?
  defaultPhoneNumber  String?
  defaultAddress      String?
  defaultMeetingNotes String?

  bookingsCreated  Booking[]             @relation("BookingCreator")
  bookingsReceived Booking[]             @relation("BookingRecipient")
  calendarTokens   CalendarToken[]
  preferences      UserPreference?
  coachingPackages CoachingPackage[]
  sessions         UserSession[]
  followUpSettings UserFollowUpSettings?
}

model CalendarToken {
  id                String    @id @default(uuid())
  userId            String
  provider          String
  accessToken       String
  refreshToken      String?
  expiresAt         DateTime?
  email             String
  accountName       String? // Display name for this specific account
  isPrimary         Boolean   @default(false) // Which account is primary for this provider
  isAccountCalendar Boolean   @default(false) // TRUE = Account identity (login calendar), FALSE = Data source
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, email]) // Allow multiple accounts per provider, but unique per email
  @@index([userId, provider])
}

model Booking {
  id             String  @id @default(uuid())
  creatorId      String?
  recipientId    String?
  creatorEmail   String
  creatorName    String
  recipientEmail String?
  recipientName  String?
  title          String
  description    String?
  duration       Int     @default(30)
  status         String  @default("pending")
  shareToken     String  @unique

  selectedTime DateTime?
  timeZone     String    @default("UTC")

  // Enhanced meeting location system
  meetingType  String  @default("video") // video, phone, in-person, custom
  meetingLink  String? // Video call link
  phoneNumber  String? // Phone number or "I'll call you"
  address      String? // In-person address
  meetingNotes String? // Custom instructions

  // Group meeting support
  isGroupMeeting  Boolean @default(false)
  maxParticipants Int     @default(2)

  // Group meeting deadline system
  participantDeadline      DateTime? // When participants must connect by
  autoSelectAtDeadline     Boolean   @default(false) // Whether to auto-select time at deadline
  deadlineHours            Int       @default(48) // Hours from creation to deadline
  allParticipantsConnected Boolean   @default(false) // Track when everyone is ready
  readyForSelection        DateTime? // When organizer can/should select time

  // Recurring session support
  isRecurring      Boolean   @default(false)
  recurringPattern String? // weekly, biweekly, monthly
  recurringEndDate DateTime?
  parentBookingId  String? // For recurring session instances

  // Organizer scheduling preferences (stored per booking)
  timeUrgency    String? @default("flexible") // urgent, flexible
  roughTimeframe String? // this_week, next_week, no_preference
  timeOfDayPref  String? // morning, afternoon, no_preference
  avoidDays      String? // comma-separated day numbers to avoid
  preferredDays  String? // comma-separated day numbers preferred

  googleEventId  String?
  outlookEventId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  creator            User?                    @relation("BookingCreator", fields: [creatorId], references: [id])
  recipient          User?                    @relation("BookingRecipient", fields: [recipientId], references: [id])
  suggestions        TimeSuggestion[]
  participants       BookingParticipant[]
  coachingSession    CoachingSession?
  rescheduleRequests GroupRescheduleRequest[]
  followUps          MeetingFollowUp[]
}

model TimeSuggestion {
  id        String   @id @default(uuid())
  bookingId String
  startTime DateTime
  endTime   DateTime
  score     Float
  selected  Boolean  @default(false)

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
}

// User Preferences for time/meeting preferences
model UserPreference {
  id     String @id @default(uuid())
  userId String @unique

  // Time preferences
  earliestStartTime String  @default("09:00") // 24hr format
  latestEndTime     String  @default("17:00")
  preferredDays     String  @default("1,2,3,4,5") // 1=Mon,2=Tue...7=Sun
  avoidDays         String? // Days to avoid

  // Buffer preferences
  bufferMinutes   Int     @default(15)
  allowBackToBack Boolean @default(false)
  blockLunchBreak Boolean @default(false) // Whether to block lunch hour from suggestions
  lunchBreakStart String  @default("12:00")
  lunchBreakEnd   String  @default("13:00")

  // Scheduling restrictions
  allowSameDayScheduling Boolean @default(false)
  minimumNoticeHours     Int     @default(24) // Minimum hours before meeting can be scheduled

  // Meeting type preferences
  preferredMeetingType String @default("video") // video, phone, in-person

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Group meeting participants
model BookingParticipant {
  id                String    @id @default(uuid())
  bookingId         String
  email             String
  name              String
  status            String    @default("pending") // pending, calendar_connected, confirmed, declined, missed_deadline
  calendarConnected Boolean   @default(false)
  connectedAt       DateTime?
  remindersSent     Int       @default(0) // Track reminder emails sent
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@unique([bookingId, email])
}

// Coaching packages for package management
model CoachingPackage {
  id              String   @id @default(uuid())
  coachId         String
  name            String
  description     String?
  totalSessions   Int
  sessionDuration Int      @default(60)
  pricePerSession Float?
  totalPrice      Float?
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  coach            User              @relation(fields: [coachId], references: [id], onDelete: Cascade)
  coachingSessions CoachingSession[]
}

// Individual coaching sessions
model CoachingSession {
  id             String   @id @default(uuid())
  bookingId      String   @unique
  packageId      String?
  sessionNumber  Int      @default(1)
  totalSessions  Int?
  status         String   @default("scheduled") // scheduled, completed, cancelled
  sessionNotes   String?
  intakeFormData String? // JSON string for intake form responses
  paymentStatus  String   @default("pending") // pending, paid, failed
  paymentId      String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  booking Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  package CoachingPackage? @relation(fields: [packageId], references: [id])
}

// Group rescheduling requests
model GroupRescheduleRequest {
  id                String   @id @default(uuid())
  originalBookingId String
  requesterId       String
  status            String   @default("pending") // pending, confirmed, cancelled
  suggestedTimes    String // JSON array of suggested times
  participantVotes  String? // JSON object of participant votes
  autoConfirmAt     DateTime // 24-hour deadline
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  originalBooking Booking @relation(fields: [originalBookingId], references: [id], onDelete: Cascade)

  @@index([originalBookingId])
}

model UserSession {
  id           String   @id @default(uuid())
  userId       String
  sessionToken String   @unique
  ipAddress    String?
  userAgent    String?
  location     String? // City, Country (from IP geolocation)
  device       String? // Parsed from user agent
  browser      String? // Parsed from user agent
  loginMethod  String? // google, microsoft, email
  isActive     Boolean  @default(true)
  expiresAt    DateTime
  lastActivity DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionToken])
}

// Follow-up tracking for meeting requests
model MeetingFollowUp {
  id                      String    @id @default(uuid())
  bookingId               String
  followUpNumber          Int // 1, 2, 3 (max follow-ups)
  scheduledSendTime       DateTime // When this should be sent (business hours calculated)
  actualSentTime          DateTime? // When this was actually sent
  sentAt                  DateTime? // Legacy field for compatibility
  openedAt                DateTime? // Email open tracking
  clickedAt               DateTime? // Link click tracking
  emailType               String // 'follow_up_1', 'follow_up_2', 'final_notice'
  status                  String    @default("scheduled") // scheduled, sent, opened, clicked, bounced, unsubscribed, cancelled
  recipientEmail          String
  businessHoursCalculated Boolean   @default(true) // Whether business hours logic was used
  organizerTimezone       String? // Organizer's timezone when scheduled
  createdAt               DateTime  @default(now())

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([recipientEmail])
  @@index([scheduledSendTime])
  @@index([status])
}

// User follow-up preferences and settings
model UserFollowUpSettings {
  id                          String   @id @default(uuid())
  userId                      String   @unique
  enabledByDefault            Boolean  @default(true) // Auto-enable follow-ups for new meetings
  businessHoursOnly           Boolean  @default(true) // Send only during business hours
  businessHoursStart          Int      @default(9) // Business hours start (24hr format)
  businessHoursEnd            Int      @default(17) // Business hours end (24hr format)
  businessDays                String   @default("1,2,3,4,5") // Monday-Friday
  timezone                    String? // User's timezone (from calendar integration)
  holidayCalendarEnabled      Boolean  @default(true) // Pause during major holidays
  firstFollowUpBusinessHours  Int      @default(48) // Business hours for first follow-up
  secondFollowUpBusinessHours Int      @default(72) // Business hours for second follow-up
  maxFollowUps                Int      @default(2) // Max number of follow-ups
  customTemplate              String? // Custom follow-up message template
  respectUnsubscribes         Boolean  @default(true) // Honor recipient unsubscribe requests
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Recipient unsubscribe preferences
model RecipientUnsubscribe {
  id              String   @id @default(uuid())
  recipientEmail  String
  organizerEmail  String // Can unsubscribe from specific organizer
  unsubscribeType String // 'organizer_specific', 'all_follow_ups'
  unsubscribedAt  DateTime @default(now())
  ipAddress       String?
  userAgent       String?

  @@unique([recipientEmail, organizerEmail])
  @@index([recipientEmail])
  @@index([organizerEmail])
}

// Holiday calendar for business hours calculations
model FollowUpHoliday {
  id               String   @id @default(uuid())
  date             DateTime // Holiday date
  name             String // Holiday name (e.g., "Christmas", "New Year's Day")
  countryCode      String   @default("US") // Country/region code
  enabledByDefault Boolean  @default(true) // Whether this holiday is active by default
  createdAt        DateTime @default(now())

  @@unique([date, countryCode])
  @@index([date])
  @@index([countryCode])
}

model Analytics {
  id        String   @id @default(uuid())
  event     String
  userId    String?
  bookingId String?
  metadata  String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([event])
}
